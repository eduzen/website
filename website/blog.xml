<?xml version="1.0" encoding="utf-8"?>
<django-objects version="1.0"><object model="blog.tag" pk="1"><field name="word" type="CharField">nginx</field><field name="slug" type="CharField">nginx</field></object><object model="blog.tag" pk="2"><field name="word" type="CharField">gunicorn</field><field name="slug" type="CharField">gunicorn</field></object><object model="blog.tag" pk="3"><field name="word" type="CharField">python</field><field name="slug" type="CharField">python</field></object><object model="blog.post" pk="1"><field name="author" rel="ManyToOneRel" to="auth.user">1</field><field name="title" type="CharField">Cómo configurar nginx - gunicorn - django</field><field name="pompadour" type="CharField">Una guia para deployment de django</field><field name="slug" type="SlugField">nginx-gunicorn-django</field><field name="created_date" type="DateField">2017-01-27</field><field name="published_date" type="DateField">2017-01-27</field><field name="text" type="TextField">&lt;ol&gt;&lt;li&gt;&lt;p&gt;Para configurar &lt;strong&gt;nginx&lt;/strong&gt; es necesario, en primer lugar, crear un archivo espec&amp;iacute;fico para nuestro sitio web, esto es, un archivo de configuraci&amp;oacute;n para nuestro proyecto:&lt;/p&gt;&lt;p&gt;&lt;pre&gt;&lt;code&gt;sudo touch /etc/nginx/sites-available/myproject&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Luego al editarlo podemos poner una configuración b&amp;aacute;sica:
	&lt;pre&gt;
&lt;code&gt;sudo vim /etc/nginx/sites-available/myproject&lt;/code&gt;
&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;
	&lt;pre&gt;
&lt;code&gt; 
server { 
    listen 80; 
    server_name www.midominio.com dominio.com 192.168.1.15; 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;/p&gt;
	&lt;pre&gt;
&lt;code&gt; 	
worker_processes 1;

user nobody nogroup;
# &amp;#39;user nobody nobody;&amp;#39; for systems with &amp;#39;nobody&amp;#39; as a group instead
pid /tmp/nginx.pid;
error_log /tmp/nginx.error.log;

events {
  worker_connections 1024; # increase if you have lots of clients
  accept_mutex off; # set to &amp;#39;on&amp;#39; if nginx worker_processes &amp;gt; 1
  # &amp;#39;use epoll;&amp;#39; to enable for Linux 2.6+
  # &amp;#39;use kqueue;&amp;#39; to enable for FreeBSD, OSX
}

http {
  include mime.types;
  # fallback in case we can&amp;#39;t determine a type
  default_type application/octet-stream;
  access_log /tmp/nginx.access.log combined;
  sendfile on;

  upstream app_server {
    # fail_timeout=0 means we always retry an upstream even if it failed
    # to return a good HTTP response

    # for UNIX domain socket setups
    server unix:/tmp/gunicorn.sock fail_timeout=0;

    # for a TCP configuration
    # server 192.168.0.7:8000 fail_timeout=0;
  }

  server {
    # if no Host match, close the connection to prevent host spoofing
    listen 80 default_server;
    return 444;
  }

  server {
    # use &amp;#39;listen 80 deferred;&amp;#39; for Linux
    # use &amp;#39;listen 80 accept_filter=httpready;&amp;#39; for FreeBSD
    listen 80;
    client_max_body_size 4G;

    # set the correct host(s) for your site
    server_name example.com www.example.com;

    keepalive_timeout 5;

    # path for static files
    root /path/to/app/current/public;

    location / {
      # checks for static file, if not found proxy to app
      try_files $uri @proxy_to_app;
    }

    location @proxy_to_app {
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      # enable this if and only if you use HTTPS
      # proxy_set_header X-Forwarded-Proto https;
      proxy_set_header Host $http_host;
      # we don&amp;#39;t want nginx trying to do something clever with
      # redirects, we set the Host: header above already.
      proxy_redirect off;
      proxy_pass http://app_server;
    }

    error_page 500 502 503 504 /500.html;
    location = /500.html {
      root /path/to/app/current/public;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;

	&lt;p&gt;para ver m&amp;aacute;s acerca de esta configuraci&amp;oacute;n&lt;a href="https://github.com/benoitc/gunicorn/blob/master/examples/nginx.conf"&gt;nginx.conf&lt;/a&gt;&lt;/p&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;Crear link simbolico&lt;/p&gt;

	&lt;pre&gt;
&lt;code&gt;sudo ln -s /etc/nginx/sites-available/myproject /etc/nginx/sites-enabled&lt;/code&gt;
&lt;/pre&gt;
	&lt;/li&gt;
	&lt;li&gt;
	&lt;p&gt;Comandos b&amp;aacute;sicos&lt;/p&gt;

	&lt;pre&gt;
&lt;code&gt;sudo nginx -t &lt;/code&gt;&lt;/pre&gt;

	&lt;pre&gt;
&lt;code&gt;sudo systemctl restart nginx&lt;/code&gt;&lt;/pre&gt;
	&lt;/li&gt;
&lt;/ol&gt;</field><field name="tags" rel="ManyToManyRel" to="blog.tag"><object pk="1"></object><object pk="2"></object></field></object><object model="blog.post" pk="2"><field name="author" rel="ManyToOneRel" to="auth.user">1</field><field name="title" type="CharField">Etiquetas o Variables</field><field name="pompadour" type="CharField">una reflexión sobre las variables en python</field><field name="slug" type="SlugField">python-labels-variables</field><field name="created_date" type="DateField">2017-05-01</field><field name="published_date" type="DateField">2017-05-01</field><field name="text" type="TextField">&lt;p&gt;Las variables son etiquetas, &lt;em&gt;labels&lt;/em&gt;, y no son como muchos piensas cajas, &lt;em&gt;boxes&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;De hecho al crear una variable &lt;em&gt;a&lt;/em&gt; con los numeros del 0 al 5, el contenido referenciado puede compartirse con otra variable &lt;em&gt;b&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; a = range(5)
&amp;gt;&amp;gt;&amp;gt; b = a
&amp;gt;&amp;gt;&amp;gt; a.append(9)
&amp;gt;&amp;gt;&amp;gt; b
[0, 1, 2, 3, 4, 9]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;En este sentido, &lt;em&gt;a&lt;/em&gt; y &lt;em&gt;b &lt;/em&gt;no solo tienen lo mismo, sino que hacen referencia a lo mismo.&lt;/p&gt;
&lt;pre&gt;
&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; b == a
True
&amp;gt;&amp;gt;&amp;gt; b is a
True&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;De hecho la comparci&amp;oacute;n &amp;quot;a == b&amp;quot; es un &lt;em&gt;syntactic sugar&lt;/em&gt; para &lt;em&gt;a.__eq__(b)&lt;/em&gt; .&lt;/p&gt;
&lt;pre&gt;
&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; a.__eq__(b)
True
&amp;gt;&amp;gt;&amp;gt; id(a) == id(b)
True&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The *is* operator is faster than == , because it cannot be overloaded, so Python does not&lt;br /&gt;
have to find and invoke special methods to evaluate it, and computing is as simple as&lt;br /&gt;
comparing two integer ids. In contrast, a == b is syntactic sugar for a.__eq__(b) . The&lt;br /&gt;
__eq__ method inherited from object compares object ids, so it produces the same&lt;br /&gt;
result as is . But most built-in types override __eq__ with more meaningful implemen‐&lt;br /&gt;
tations that actually take into account the values of the object attributes. Equality may&lt;br /&gt;
involve a lot of processing &amp;mdash; for example, when comparing large collections or deeply&lt;br /&gt;
nested structures.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
The relative immutability of tuples&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; t1 = (1, 2, [30, 40])&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; id(t1[-1])&lt;br /&gt;
4302515784&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; t1[-1].append(99)&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; t1&lt;br /&gt;
&amp;gt;&amp;gt;&amp;gt; id(t1[-1])&lt;br /&gt;
4302515784&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</field><field name="tags" rel="ManyToManyRel" to="blog.tag"><object pk="3"></object></field></object></django-objects>